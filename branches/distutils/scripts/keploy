#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# keploy - SSH Public Key Deplyment Utility
# Copyright Â© 2007 Greg Swift gregswift@gmail.com
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
 Import Standard Modules
"""
from optparse import OptionParser, make_option
from os import environ
import signal

"""
 Import Local Modules
"""
import keploy as k

"""
 Define Variables
"""
USAGE = '%prog [options] [hosts]'
OPTIONS_LIST = [
  make_option("-i", dest="id_file", default=None,
      help="Selects a file from which the public identity will be read"),
  make_option("-l", dest="login_name", default=None,
      help="Specifies the user to log in as on the remote machine(s)"),
  make_option("-f", dest="target_file", default=None,
      help="Read list of targets from a text file, with one line per host"),
  make_option("-k", dest="use_known", action="store_true", default=False,
      help="Read list of targets from ~/.ssh/known_hosts files"),
  make_option("-r", dest="remove", action="store_true", default=False,
      help="Remove primary identity from remote machine(s)"),
  make_option("-c", dest="old_id_file", default=False,
      help="Specifies which old identity to replace with new idenity"),
  make_option("-A", dest="forward", action="store_true", default=False,
      help="Toggle agent forwarding on/off for remote(s)"),
  make_option("-v", dest="verbose", action="store_true", default=True,
      help="Give verbose output"),
  make_option("-q", dest="verbose", action="store_false",
      help="Quiet the output")
]
#  make_option("-y", dest="accept_unknown", action="store_true", default=False,
#      help="Accept and save new host key if visiting host for first time"),

"""
 Define Functions
"""
def handler(signum, frame):
  if signum == 2:
    k.standardOut('Caught interrupt signal, cleaning up...')
  elif signum == 15:
    k.standardOut('Cleaning up...')
  k.cleanUp(1)

def getOptions(opt_list, usage, version=''):
  """
  Process and return w/ the cli options

  returns dict(opts), list(args)
  """
  k.debugOut('getOptions(opt_list=%s, usage=%s, version=%s)' % (opt_list, 
      usage, version))
  p = OptionParser(option_list=opt_list, usage=usage, version=version)
  (opts, args) = p.parse_args()
  k.debugOut(opts, 'Parsed opts are')
  k.debugOut(args, 'Parsed args are')
  return (opts, args)

def validateOptions(vars, opts, args):
  """
  Process and return w/ the cli options

  returns dict(opts), list(args)
  """
  k.debugOut('validateOptions(opts=%s, args=%s)' % (opts, args))
  if (not opts.remove) and (not opts.old_id_file):
    k.standardOut(k.PW_WARN, opts.verbose)
  k.standardOut('Preparing to deploy ssh key...', opts.verbose)
  if not opts.login_name:
    opts.login_name = environ['USER']
  opts.login_name = '-l %s' % (opts.login_name)
  if opts.id_file is None:
    opts.id_file = k.findDefaultIdentityFile(vars.id_files)
  return (opts, args)

def main(vars):
  # Set the signals which will be handled by the signal handler
  signal.signal(signal.SIGINT, handler)
  signal.signal(signal.SIGTERM, handler)

  # Grap input from cli, and validate it
  (opts, args) = getOptions(OPTIONS_LIST, USAGE)
  (opts, args) = validateOptions(vars, opts, args)

  if len(args) < 1 :
    if opts.target_file is not None:
      # Gather up available hosts from supplied file
      (hosts) = k.getHostsFromFile(opts.target_file, verbose=opts.verbose)
      host_msg = '\n\t\t'.join(hosts)
    elif opts.use_known:
      # Gather up available hosts from known_host files, if we can
      (hosts) = k.getHostsFromFile(known=opts.use_known, verbose=opts.verbose)
      host_msg = '\n\t\t'.join(hosts)
    else:
      k.errorOut("No targets defined.")
  else:
    hosts = args
    host_msg = hosts[0]
  k.standardOut('\tFound host(s):\n\t\t%s' % (host_msg), opts.verbose)

  (identity) = k.getIdentity(opts.id_file, opts.verbose)

  if opts.old_id_file:
    k.standardOut('\tFinding old public idenity file:', opts.verbose)
    old_identity = k.getIdentity(opts.old_id_file, opts.verbose)
    opts.remove = True

"""
 Run application
"""
if __name__ == "__main__":
  vars = k.KeployVariables()
  if (vars.ssh_bin is None):
    k.errorOut('Cannot locate ssh binary')
  elif (vars.ssh_bin is False):
    k.errorOut('%s is not executable by your user' % (vars.ssh_bin))
  main(vars)
