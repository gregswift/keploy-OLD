#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# keploy - SSH Public Key Deplyment Utility
# Copyright Â© 2007 Greg Swift gregswift@gmail.com
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
 Import Standard Modules
"""
from optparse import OptionParser, make_option
from os import environ
import signal

"""
 Import Local Modules
"""
from keploy import *

"""
 Define Variables
"""
USAGE = '%prog [options] [hosts]'
OPTIONS_LIST = [
  make_option("-i", dest="id_file", default=None,
      help="Selects a file from which the public identity will be read"),
  make_option("-l", dest="login_name", default=None,
      help="Specifies the user to log in as on the remote machine(s)"),
  make_option("-f", dest="target_file", default=None,
      help="Read list of targets from a text file, with one line per host"),
  make_option("-k", dest="use_known", action="store_true", default=False,
      help="Read list of targets from ~/.ssh/known_hosts files"),
  make_option("-r", dest="remove", action="store_true", default=False,
      help="Remove primary identity from remote machine(s)"),
  make_option("-c", dest="old_id_file", default=False,
      help="Specifies which old identity to replace with new idenity"),
  make_option("-A", dest="forward", action="store_true", default=False,
      help="Toggle agent forwarding on/off for remote(s)"),
  make_option("-v", dest="verbose", action="store_true", default=True,
      help="Give verbose output"),
  make_option("-q", dest="verbose", action="store_false",
      help="Quiet the output")
]
#  make_option("-y", dest="accept_unknown", action="store_true", default=False,
#      help="Accept and save new host key if visiting host for first time"),

"""
 Define Functions
"""
def handler(signum, frame):
  if signum == 2:
    standardOut('Caught interrupt signal, cleaning up...')
  elif signum == 15:
    standardOut('Cleaning up...')
  cleanUp(1)

def getOptions(opt_list, usage, version=''):
  """
  Process and return w/ the cli options

  returns dict(opts), list(args)
  """
  debugOut('getOptions(opt_list=%s, usage=%s, version=%s)' % (opt_list, 
      usage, version))
  p = OptionParser(option_list=opt_list, usage=usage, version=version)
  (opts, args) = p.parse_args()
  debugOut(opts, 'Parsed opts are')
  debugOut(args, 'Parsed args are')
  return (opts, args)

def validateOptions(vars, opts, args):
  """
  Process and return w/ the cli options

  returns dict(opts), list(args)
  """
  debugOut('validateOptions(opts=%s, args=%s)' % (opts, args))
  if (not opts.remove) and (not opts.old_id_file):
    standardOut(PW_WARN, opts.verbose)
  standardOut('Preparing to deploy ssh key...', opts.verbose)
  if not opts.login_name:
    opts.login_name = environ['USER']
  opts.login_name = '-l %s' % (opts.login_name)
  if opts.id_file is None:
    opts.id_file = findDefaultIdentityFile(vars.id_files)
  if opts.old_id_file:
    opts.remove = True
  debugOut(opts, 'Handled opts are')
  debugOut(args, 'Handled args are')
  return (opts, args)

def main(vars):
  # Set the signals which will be handled by the signal handler
  signal.signal(signal.SIGINT, handler)
  signal.signal(signal.SIGTERM, handler)

  # Grap input from cli, and validate it
  (opts, args) = getOptions(OPTIONS_LIST, USAGE)
  (opts, args) = validateOptions(vars, opts, args)

  if len(args) < 1 :
    if opts.target_file is not None:
      host_file = opts.target_file
    elif opts.use_known:
      if isHostsFileHashed():
        msg = "The known_hosts files are hashed.  Please "
        msg += "specify host or alternate file to parse at cli"
        errorOut(msg)
      host_file = vars.host_files
    else:
      errorOut("No targets defined.")
    # Gather up available hosts from supplied file
    try:
      hosts = getHostsFromFile(opts.host_file, verbose=opts.verbose)
    except KeployError, msg:
      errorOut(msg)
    host_msg = '\n\t\t'.join(hosts)
  else:
    hosts = args
    host_msg = hosts[0]
  standardOut('\tFound host(s):\n\t\t%s' % (host_msg), opts.verbose)

  identity = getIdentity(opts.id_file, opts.verbose)

  if opts.old_id_file:
    standardOut('\tFinding old public idenity file:', opts.verbose)
    old_identity = getIdentity(opts.old_id_file, opts.verbose)
    # add an error here properly if can't find old id file?

  for host in hosts:
    ssh_call = '%s -qq %s %s \'' % (ssh_bin, options.userid, host)
    end_ssh_call = '\''
    standardOut('\tWorking on host: %s' % (host), options.verbose)
    if (options.forward):
     toggleAgentForwarding(False, ssh_call, end_ssh_call, options.verbose)
    command = ''
    try:
     old_identity
    except:
     use_identity = identity
    else:
     use_identity = old_identity
    # Make ssh home dir and set permissions
    command += 'mkdir %s &> /dev/null; chmod 700 %s;' % (
      ssh_home_dir, ssh_home_dir)
    # Remove identity from file, set permissions
    command +=  'grep -v \"%s\" %s > %s 2> /dev/null;' % (
      identity, auth_keys_file, tmp_file)
    command += 'mv -f %s %s 2>/dev/null; chmod 600 %s 2> /dev/null;' % (
      tmp_file, auth_keys_file, auth_keys_file)
    if (not options.remove or options.old_id_file):
     use_identity = identity
     # Then append the pub identity into the authorized_keys file, and grep it
     command += 'echo \'%s\' >> %s 2> /dev/null; chmod 600 %s; grep \"%s\" %s' % (
       use_identity, auth_keys_file, auth_keys_file, use_identity, auth_keys_file)
    remote_command=ssh_call+command+end_ssh_call
    debugOut(remote_command, 'Executing')
    ret = os.popen(remote_command).readlines()
    if (ret):
     if (options.old_id_file):
      status = 'changed'
     elif (options.remove):
      status = 'failed to remove'
     else:
      status = 'deployed'
     for line in ret:
      debugOut(line)
    else:
     if (options.remove):
      status = 'removed'
     else:
      status = 'failed to deploy'
    standardOut('\t\tPublic Identity Key: %s' % (status), options.verbose)

    if (options.forward):
     if (not options.remove or options.old_id_file):
      toggleAgentForwarding(True, ssh_call, end_ssh_call, options.verbose)

"""
 Run application
"""
if __name__ == "__main__":
  vars = KeployVariables()
  if (vars.ssh_bin is None):
    errorOut('Cannot locate ssh binary')
  elif (vars.ssh_bin is False):
    errorOut('%s is not executable by your user' % (vars.ssh_bin))
  main(vars)
